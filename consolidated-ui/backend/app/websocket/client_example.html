<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket Client Example</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .connected {
            background-color: #d4edda;
            color: #155724;
        }
        .disconnected {
            background-color: #f8d7da;
            color: #721c24;
        }
        .messages {
            border: 1px solid #ddd;
            padding: 10px;
            height: 300px;
            overflow-y: auto;
            margin: 10px 0;
        }
        .message {
            padding: 5px;
            margin: 5px 0;
            border-left: 3px solid #007bff;
            background-color: #f8f9fa;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
        }
        input {
            padding: 8px;
            width: 300px;
        }
    </style>
</head>
<body>
    <h1>FastAPI WebSocket Client</h1>

    <div>
        <input type="text" id="token" placeholder="JWT Token" />
        <button onclick="connect()">Connect</button>
        <button onclick="disconnect()">Disconnect</button>
    </div>

    <div id="status" class="status disconnected">
        Disconnected
    </div>

    <div>
        <h3>Connection Info</h3>
        <div id="connection-info">Not connected</div>
    </div>

    <div>
        <h3>Messages</h3>
        <div id="messages" class="messages"></div>
    </div>

    <div>
        <h3>Health Metrics</h3>
        <pre id="health-metrics">No data</pre>
    </div>

    <script>
        let ws = null;
        let connectionId = null;
        let lastEventId = null;
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 5;
        let reconnectDelay = 1000; // Start at 1 second

        function connect() {
            const token = document.getElementById('token').value;
            if (!token) {
                alert('Please enter a JWT token');
                return;
            }

            // Build WebSocket URL
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.host || 'localhost:8000';
            let wsUrl = `${protocol}//${host}/ws?token=${encodeURIComponent(token)}`;

            // Add connection_id for reconnection
            if (connectionId) {
                wsUrl += `&connection_id=${connectionId}`;
            }

            // Add last_event_id for event replay
            if (lastEventId) {
                wsUrl += `&last_event_id=${lastEventId}`;
            }

            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                updateStatus('connected');
                reconnectAttempts = 0;
                reconnectDelay = 1000;
                addMessage('System', 'Connected to WebSocket server');
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleMessage(data);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                addMessage('Error', 'WebSocket error occurred');
            };

            ws.onclose = () => {
                updateStatus('disconnected');
                addMessage('System', 'Disconnected from WebSocket server');

                // Auto-reconnect with exponential backoff
                if (reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    const delay = reconnectDelay * Math.pow(2, reconnectAttempts - 1);
                    addMessage('System', `Reconnecting in ${delay/1000}s (attempt ${reconnectAttempts}/${maxReconnectAttempts})`);

                    setTimeout(() => {
                        connect();
                    }, delay);
                } else {
                    addMessage('Error', 'Max reconnection attempts reached');
                }
            };
        }

        function disconnect() {
            if (ws) {
                ws.close();
                ws = null;
            }
        }

        function handleMessage(data) {
            const { type, event_id, timestamp } = data;

            // Store last event ID for reconnection
            if (event_id) {
                lastEventId = event_id;
            }

            switch (type) {
                case 'ping':
                    // Send pong
                    sendPong(event_id);
                    addMessage('Heartbeat', 'Received ping, sent pong');
                    break;

                case 'ack':
                    // Store connection_id from first ack
                    if (data.ack_event_id === 'initial_connect') {
                        addMessage('System', 'Connection acknowledged');
                        updateConnectionInfo(data);
                    }
                    break;

                case 'task_status_update':
                    addMessage('Task Update', JSON.stringify(data.data, null, 2));
                    break;

                case 'agent_activity_update':
                    addMessage('Agent Activity', JSON.stringify(data.data, null, 2));
                    break;

                case 'calendar_event_created':
                    addMessage('Calendar Event', JSON.stringify(data.data, null, 2));
                    break;

                case 'error':
                    addMessage('Error', data.error);
                    break;

                default:
                    addMessage('Unknown', JSON.stringify(data, null, 2));
            }
        }

        function sendPong(pingEventId) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const pong = {
                    type: 'pong',
                    event_id: generateEventId(),
                    timestamp: new Date().toISOString()
                };
                ws.send(JSON.stringify(pong));
            }
        }

        function generateEventId() {
            return 'evt_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function updateStatus(status) {
            const statusDiv = document.getElementById('status');
            if (status === 'connected') {
                statusDiv.className = 'status connected';
                statusDiv.textContent = 'Connected';
            } else {
                statusDiv.className = 'status disconnected';
                statusDiv.textContent = 'Disconnected';
            }
        }

        function updateConnectionInfo(data) {
            const infoDiv = document.getElementById('connection-info');
            infoDiv.innerHTML = `
                <strong>Event ID:</strong> ${data.event_id}<br>
                <strong>Last Event ID:</strong> ${lastEventId || 'N/A'}
            `;
        }

        function addMessage(type, content) {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            messageDiv.innerHTML = `
                <strong>${type}</strong> [${new Date().toLocaleTimeString()}]<br>
                ${content}
            `;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        // Fetch health metrics every 5 seconds
        setInterval(async () => {
            try {
                const response = await fetch('/ws/health');
                const health = await response.json();
                document.getElementById('health-metrics').textContent =
                    JSON.stringify(health, null, 2);
            } catch (error) {
                console.error('Error fetching health metrics:', error);
            }
        }, 5000);
    </script>
</body>
</html>
