# Skill-Forge Cognitive Architecture Integration

## Kanitsal Cerceve (Evidential Frame Activation)
Kaynak dogrulama modu etkin.



**Version**: 3.1.0
**Purpose**: Integrate VERIX epistemic notation, VERILINGUA cognitive frames, DSPy optimization, and GlobalMOO multi-objective optimization into skill-forge.

## Overview

This addendum enhances skill-forge to:
1. Generate skills with VERIX-compliant instructions
2. Embed VERILINGUA frame activation in skills
3. Use DSPy for skill SOP optimization
4. Track skill quality with GlobalMOO multi-objective optimization

## VERIX Integration

### Skills Output VERIX-Compliant Instructions

Every skill generated by skill-forge includes epistemic markers:

```yaml
# In generated skill YAML frontmatter
cognitive_architecture:
  verix:
    strictness: moderate  # relaxed | moderate | strict
    required_markers:
      - ground  # Source for claims
      - confidence  # Certainty level
    optional_markers:
      - state  # hypothetical | actual | confirmed
    output_format: L1_compressed  # L0_full | L1_compressed | L2_minimal
```

### Skill Instructions with VERIX

**Phase 5b Enhancement**: After instruction crafting, apply VERIX annotation

```python
def annotate_skill_instructions(instructions: str, config: VerixConfig) -> str:
    """
    Add VERIX markers to skill instructions.

    Example transformation:
    Before: "Run the test suite to verify changes"
    After: "[assert|neutral] Run the test suite to verify changes [ground:testing-sop.md] [conf:0.95]"
    """
    from cognitive_architecture.core.verix import VerixAnnotator

    annotator = VerixAnnotator(
        strictness=config.strictness,
        compression=config.output_format
    )

    # Annotate each instruction
    annotated = annotator.annotate(instructions)

    return annotated
```

## VERILINGUA Integration

### Phase 0.5 Enhancement: Skill-Specific Frame Selection

```yaml
# Frame selection based on skill category
skill_frame_mapping:
  development:
    primary: aspectual  # Completion tracking
    secondary: [morphological]  # Code semantics
    activation: "Sostoyanie zavershenia - Track completion state"

  research:
    primary: evidential  # Source verification
    secondary: [morphological]  # Semantic precision
    activation: "Kaynak dogrulama - Verify all sources"

  quality:
    primary: evidential  # Evidence-based findings
    secondary: [aspectual]  # Issue tracking
    activation: "Kanitsal cerceve - Evidence-based analysis"

  orchestration:
    primary: compositional  # Structure building
    secondary: [aspectual, honorific]  # Coordination
    activation: "Zusammensetzung - Build coordinated structure"

  documentation:
    primary: compositional  # Document structure
    secondary: [honorific]  # Audience awareness
    activation: "Baustein-Struktur - Structured documentation"
```

### Frame Embedding in Generated Skills

```markdown
## Generated Skill Template with Frame

---
name: {skill-name}
version: 1.0.0
cognitive_architecture:
  verilingua:
    primary_frame: {selected_frame}
    secondary_frames: {secondary_list}
    activation_phrase: |
      {multilingual_activation_phrase}
  verix:
    strictness: moderate
    required_markers: [ground, confidence]
---

## {Frame Activation Section}

{Multilingual activation phrase in native language}

## Core Workflow

[assert|neutral] Step 1: {instruction} [ground:sop-doc] [conf:0.90]
[assert|neutral] Step 2: {instruction} [ground:sop-doc] [conf:0.85]
...
```

## DSPy Integration

### Skill Generation as DSPy Module

```python
from dspy import ChainOfThought, Signature, Module

class SkillGenerationSignature(Signature):
    """Generate production-grade skill with cognitive architecture."""

    user_request: str = InputField(desc="What skill to create")
    target_domain: str = InputField(desc="Skill domain")
    complexity: str = InputField(desc="simple | medium | complex")

    skill_yaml: str = OutputField(desc="YAML frontmatter with cognitive_architecture")
    skill_content: str = OutputField(desc="SKILL.md content with VERIX markers")
    frame_activation: str = OutputField(desc="Multilingual frame activation section")
    verix_compliance: float = OutputField(desc="VERIX marker coverage 0-1")
    test_cases: list = OutputField(desc="Validation test cases")


class SkillForgeDSPy(Module):
    """DSPy module for skill generation with cognitive architecture."""

    def __init__(self):
        super().__init__()
        self.generator = ChainOfThought(SkillGenerationSignature)
        self.verix_validator = VerixValidator()
        self.frame_registry = FrameRegistry

    def forward(self, user_request: str, target_domain: str, complexity: str):
        # Generate skill
        result = self.generator(
            user_request=user_request,
            target_domain=target_domain,
            complexity=complexity
        )

        # Validate VERIX compliance
        result.verix_compliance = self.verix_validator.score(result.skill_content)

        # Validate frame activation
        frame = self.frame_registry.get(target_domain)
        if frame:
            result.frame_score = frame.score_response(result.frame_activation)

        return result
```

### DSPy Optimization for Skill Quality

```python
from dspy import Teleprompter

def optimize_skill_generation():
    """
    Use DSPy teleprompter to optimize skill generation.
    """
    skill_forge = SkillForgeDSPy()

    # Define optimization metric
    def skill_metric(prediction, gold):
        return (
            0.3 * prediction.verix_compliance +
            0.3 * (prediction.frame_score or 0.5) +
            0.2 * len(prediction.test_cases) / 10 +  # Normalize test count
            0.2 * (1 if "cognitive_architecture" in prediction.skill_yaml else 0)
        )

    # Compile with examples
    teleprompter = Teleprompter(metric=skill_metric)
    optimized_forge = teleprompter.compile(skill_forge, trainset=training_skills)

    return optimized_forge
```

## GlobalMOO Integration

### Multi-Objective Skill Quality

```yaml
project_id: skill-forge-optimization
objectives:
  - name: verix_compliance
    description: VERIX marker coverage in instructions
    direction: maximize
    weight: 0.25

  - name: frame_alignment
    description: VERILINGUA frame activation quality
    direction: maximize
    weight: 0.20

  - name: sop_completeness
    description: All required sections present
    direction: maximize
    weight: 0.20

  - name: test_coverage
    description: Test cases cover use cases
    direction: maximize
    weight: 0.15

  - name: adversarial_pass_rate
    description: Survives Phase 7a adversarial testing
    direction: maximize
    weight: 0.15

  - name: token_efficiency
    description: Skill size vs complexity
    direction: minimize
    weight: 0.05

parameters:
  - name: verix_strictness
    type: ordinal
    values: [relaxed, moderate, strict]

  - name: frame_depth
    type: ordinal
    values: [single_phrase, paragraph, full_section]

  - name: phase_selection
    type: categorical
    values: [quick_track, expert_track]

  - name: cov_iterations
    type: ordinal
    values: [1, 2, 3]
```

### Integration with Three-MOO Cascade

```python
def cascade_optimize_skill(skill_request: str) -> GeneratedSkill:
    """
    Use ThreeMOOCascade for skill optimization.
    """
    from cognitive_architecture.optimization.cascade import ThreeMOOCascade

    cascade = ThreeMOOCascade()

    # Phase A: Structure optimization
    # - Optimize skill section organization
    # - Tune VERIX strictness

    # Phase B: Edge case discovery
    # - Find skill failure modes
    # - Expand adversarial test coverage

    # Phase C: Production refinement
    # - Distill to optimal configuration
    # - Generate final skill

    results = cascade.run(
        project_id="skill-forge-optimization",
        config_space=skill_config_space,
        evaluator=skill_evaluator
    )

    # Select best from Pareto frontier
    best_config = results.pareto_frontier.select_balanced()

    return generate_skill(skill_request, best_config)
```

## Enhanced Phase Flow

```
Phase 0: Schema Definition
    |
    v
Phase 0.5: Cognitive Frame Design (ENHANCED)
    ├── Analyze skill domain
    ├── Select VERILINGUA frame(s)
    ├── Prepare multilingual activation phrase
    └── Add cognitive_architecture to schema
    |
    v
Phase 1-1b: Intent Analysis + CoV (existing)
    |
    v
Phase 2-4: Use Case + Architecture (existing)
    |
    v
Phase 5: Instruction Crafting (ENHANCED)
    ├── Write instructions in imperative voice
    ├── Apply VERIX annotation to all claims
    └── Validate ground and confidence coverage
    |
    v
Phase 5b: Instruction Verification + VERIX Validation (ENHANCED)
    ├── Adversarial misinterpretation testing
    ├── VERIX compliance check (minimum 70%)
    └── Frame activation validation
    |
    v
Phase 6-7: Resource Development + Validation (existing)
    |
    v
Phase 7a: Adversarial Testing (existing)
    |
    v
Phase 7b: Documentation Audit (existing)
    |
    v
Phase 8: Metrics Tracking (ENHANCED)
    ├── Track V0 -> V1 -> V2 improvement
    ├── Record VERIX compliance delta
    ├── Record frame alignment delta
    └── Submit to GlobalMOO
    |
    v
Phase 9: GlobalMOO Optimization (NEW)
    ├── Run Three-MOO Cascade
    ├── Update Pareto frontier
    └── Distill optimal skill configuration
```

## Quality Gates

### VERIX Compliance Gate (Phase 5b)

```yaml
verix_quality_gate:
  minimum_instruction_coverage: 0.70  # 70% instructions have VERIX
  required_ground_types:
    - sop_reference  # Reference to skill SOP
    - external_doc   # Reference to external documentation
  confidence_range: [0.6, 1.0]  # Allowed confidence range
  block_on_failure: true
```

### Frame Alignment Gate (Phase 0.5)

```yaml
frame_quality_gate:
  frame_selection_required: true
  activation_phrase_required: true
  minimum_frame_score: 0.60
  multilingual_optional: true  # In v3.1, multilingual is optional
```

### GlobalMOO Convergence Gate (Phase 9)

```yaml
moo_quality_gate:
  minimum_pareto_points: 3
  convergence_threshold: 0.02
  required_objectives_covered: 4  # At least 4 of 6 objectives optimized
```

## Memory Integration

### Store Skill Generation Outcomes

```javascript
// Store skill generation metadata
await mcp__memory_mcp__memory_store({
  text: `Skill generated: ${skillName}. Domain: ${domain}. VERIX: ${verixScore}. Frame: ${frameScore}. Tests: ${testCount}.`,
  metadata: {
    key: `skill-forge/generations/${skillId}`,
    namespace: "foundry-optimization",
    layer: "long-term",
    tags: {
      WHO: "skill-forge",
      WHEN: new Date().toISOString(),
      PROJECT: "meta-loop",
      WHY: "skill-generation"
    }
  }
});
```

## Cross-Skill Coordination

### Integration with Other Foundry Skills

```yaml
coordination_matrix:
  prompt-architect:
    when: "Before Phase 5 instruction crafting"
    purpose: "Optimize skill instructions using evidence-based techniques"
    data_flow: "skill_instructions -> optimized_instructions"

  agent-creator:
    when: "After Phase 6 resource development"
    purpose: "Create agents that execute the skill"
    data_flow: "skill_spec -> agent_system_prompt"

  cognitive-lensing:
    when: "Phase 0.5 frame selection"
    purpose: "Select optimal cognitive frame for skill domain"
    data_flow: "skill_domain -> selected_frame"

  eval-harness:
    when: "Phase 7 validation"
    purpose: "Run benchmark and regression tests"
    data_flow: "generated_skill -> test_results"
```

## Conclusion

This addendum integrates the full cognitive architecture into skill-forge:

1. **VERIX**: All skill instructions include epistemic markers
2. **VERILINGUA**: Frame selection embedded in Phase 0.5
3. **DSPy**: Skill generation as optimizable DSPy module
4. **GlobalMOO**: Multi-objective tracking with Three-MOO Cascade

The enhanced skill-forge can now:
- Generate skills with VERIX-compliant instructions
- Embed cognitive frame activation in all skills
- Optimize skill quality through DSPy teleprompter
- Track skill effectiveness through GlobalMOO Pareto frontier


---
*Promise: `<promise>COGNITIVE_ARCHITECTURE_ADDENDUM_VERIX_COMPLIANT</promise>`*
